#!/usr/bin/env python

"""
Assumptions:

- Assumes taxon names in original simulated datasets are numbers and these 
numbers are ordered based on order of taxa in empirical matrix. This is the
behavior of some versions (hopefully all!) of MrBayes3.x.
"""


import sys
import os
import subprocess
import re
import itertools

# ----> User-Defined Options <----

if len(sys.argv) ==1:
	print 'you need the filename as an argument'
	sys.exit(-1)
else:
	empDatName = sys.argv[1]

#empDatName = "primates.nex"		# The name of the empirical data set with missing data

# ---> Defining some functions of convenience <---

def shCall( cmd ):
	subprocess.call(cmd,shell=True)
	
def cd( cmd ):
	os.chdir(cmd)
	
def ls( ):
	files = os.listdir(".")
	if (files[0] == ".DS_Store"):
		files = files[1:] # To get rid of .DS_Store
	return files

def findAllPos( string,sub ):	# Only works for non-overlapping substrings
	return [match.start() for match in re.finditer(sub,string)]
	
def findMissPos( nexFile ):
	inFile = open(nexFile,'r')
	parLine = inFile.readline()
	while ( 'matrix' not in parLine ):
		parLine = inFile.readline()
	matrixLine = inFile.readline()
	while not matrixLine.strip():
		matrixLine = inFile.readline()
	missPos = []
	while ( ';' not in matrixLine ):
		matrixLine = matrixLine.split()[1]
		gaps = findAllPos(matrixLine,'-')
		ambigs = findAllPos(matrixLine,'N')
		miss = findAllPos(matrixLine,'\?')
		gaps.extend(ambigs)
		gaps.extend(miss)
		gaps = sorted(gaps)
		missPos.append(gaps)
		matrixLine = inFile.readline()
	inFile.close()
	return missPos

def getNexHeader( nexFile ):
	"""
	Function to read in and store lines of original nexus file above data matrix
	"""
	nexHeader = []
	nexIn = open(nexFile,'r')
	readFile = nexIn.read()
	for line in readFile.splitlines(True):
		if "nexus" in line:
			nexHeader.append(line)
		if "NEXUS" in line:
			nexHeader.append(line)
		if "begin data" in line:
			nexHeader.append(line)
		if "dimensions" in line:
			nexHeader.append(line)
		if "format" in line:
			nexHeader.append(line)
		if "matrix" in line:
			nexHeader.append(line)
	nexIn.close()
	return nexHeader
	
def readMatrix( inStream ):
	"""
	Function to read in simulated sequences from a .dat file generated by seq-gen.
	Sequences are ordered by taxon number.
	"""
	inStream.readline() # Gets rid of phylip header line
	seqDict = {}
	seqs = []
	seqLine = inStream.readline()
	seqLine = seqLine.split()
	while ( len(seqLine) > 1 ):	# Reads in seqs from file and stores in dict with tax # key
		seqDict[int(seqLine[0])] = seqLine[1]
		seqLine = inStream.readline()
		seqLine = seqLine.split()
	for i in range(len(seqDict)):
		seqs.append(seqDict[i+1])
	return seqs
	
def getTaxNames( nexFile ):
	nexIn = open(nexFile,'r')
	parLine = nexIn.readline()
	while ( 'matrix' not in parLine ):
		parLine = nexIn.readline()
	name = nexIn.readline()
	while not name.strip():
		name = nexIn.readline()
	name = name.split()
	taxa = []
	while( ";" not in name ):
		taxa.append(name[0])
		name = nexIn.readline()
		name = name.split()
	return taxa
	
def outputMatrixWithMiss( outStream,header,taxa,seqs,miss ):
	for i in nexHeader:
		outStream.write( i )
	if ( len(taxa) != len(seqs) ):
		sys.exit("Number of taxon names different than number of simulated sequences! Exiting...")
	if ( len(taxa) != len(miss) ):
		sys.exit("Number of taxon names different than number of missing position lists! Exiting...")
	# Rearranging codons - ASSUMES CODON PARTITIONS START OUT AS CONTIGUOUS BLOCKS!
	for i in range( len(miss) ):
		seqList = list(seqs[i])
		seqList = intercalateCodons(seqList)
		seqs[i] = "".join(seqList)
	# Add missing data to sequences
	for i in range( len(miss) ):
		for j in miss[i]:
			seqList = list(seqs[i])
			seqList[j] = "-"
			seqs[i] = "".join(seqList)
	# Output taxon names and sequences to file
	for i in range( len(taxa) ):
		outStream.write( "%s		%s\n" % (taxa[i],seqs[i]) )
	outStream.write(";\n")
	outStream.write("End;\n")
	
def intercalateCodons( seq ):
	"""
	This function assumes the sequences have been generated under a model partitioned by codon,
	but simulated datasets are arranged with partitions in contiguous segments (e.g., codon1:1-100, 
	codon2:101-200, codon3:201-300). This function takes these contiguous segments and intercalates
	the three codons.

	If the length of the sequence is not a multiple of 3, extra nucleotides are assumed to be added 
	first to codon1, then codon2.

	Input argument (seq) needs to be a list.
	"""
	seqLen = len(seq)
	sitesPerCod = seqLen/3
	extraSites = seqLen%3
	if extraSites == 0:
		codOne = seq[0:sitesPerCod]
		codTwo = seq[sitesPerCod:2*sitesPerCod]
		codThree = seq[2*sitesPerCod:3*sitesPerCod]
	elif extraSites == 1:
		codOne = seq[0:sitesPerCod+1]
		codTwo = seq[sitesPerCod+1:(2*sitesPerCod)+1]
		codThree = seq[(2*sitesPerCod)+1:(3*sitesPerCod)+1]
	else:
		codOne = seq[0:sitesPerCod+1]
		codTwo = seq[sitesPerCod+1:(2*sitesPerCod)+2]
		codThree = seq[(2*sitesPerCod)+2:(3*sitesPerCod)+2]
	newSeq = [x for t in itertools.izip_longest(codOne,codTwo,codThree) for x in t]
	"""
	http://stackoverflow.com/questions/11125212/interleaving-lists-in-python
	"""
	newSeq = filter(lambda a: a != None, newSeq)
	"""
	http://stackoverflow.com/questions/1157106/remove-all-occurrences-of-a-value-from-a-python-list
	"""
	return newSeq

	
# ---> End function definitions <---
	
shCall("mkdir SeqOutfiles_wMiss_intercalate")
miss = findMissPos("%s" % empDatName)
nexHeader = getNexHeader("%s" % empDatName)
taxNames = getTaxNames("%s" % empDatName)
cd("SeqOutfiles")			# This script looks for datasets in a "SeqOutfiles" folder
dats = ls()
for j in dats:
	datIn = open(j,'r')
	datFileRootIn = subprocess.Popen("basename %s .dat" % j,shell=True,stdout=subprocess.PIPE)
	datFileRoot = datFileRootIn.communicate()[0].strip()
	nexOut = open("../SeqOutfiles_wMiss_intercalate/%s.nex" % datFileRoot,'w')	
	matrix = readMatrix(datIn)	# Reads in data matrix and orders taxa by number
	outputMatrixWithMiss(nexOut,nexHeader,taxNames,matrix,miss)
	datIn.close()
	nexOut.close()
cd("..") # Back out of SeqOutfiles
	